# Debugging

The most neat thing about a good debugger is that it can save you copious 
amounts of time, figuring out what went wrong when hitting save and running 
your code.

Even then, a lot of fail happens in production and will be generated by your 
user base.

The HylianShield validator is prepared for this, in a few ways:

- It holds simple and descriptive names for validators
- Validators will try to tell you what they got as input, 
what kind of type it is and what they expected as valid input.
- Some validators (we aim to revisit all of them to implement this) make use 
of the new validator context. This context registers assertions, 
intentions and violations throughout the validation process. Whenever it can,
 a validator will write down all violations encountered by the validator when
  debugging an error.

## Validator getType().

The validator type can tell a lot about the reason why something failed.

```php
<?php
$validator = new \HylianShield\Validator\Email;
echo $validator->getType(); // 'email'
```

When casting a validator to a string, that does a call to `getType`, 
so this works as well:

```php
<?php
echo $validator; // 'email'
```

## Validator getMessage()

After calling the validate method, you can use `getMessage` to see what went 
wrong with the validation. The message will tell you the last supplied value,
 the expected type and if possible show the different violations that caused 
 the validator to fail the supplied value.

```php
<?php
$validator = new \HylianShield\Validator\CoreFunction();
$validator->validate('My epic function');

echo $validator->getMessage();
```

Which will output:

```
Invalid value supplied: (string) 'My epic function'; Expected: function
Violations:
#1 Violation - Function "My epic function" does not exist - Violation code #2
```

The `CoreFunction` validator does two checks under the hood. First it checks 
if the supplied value is a string. This is true in our case, 
so it will move on to the next check, which is a simple question to the core 
API if the supplied value is an existing function. At that point it fails and
 adds a violation to the context created by the validator.
 
## Validator Context

Although a validator is perfectly capable of creating a context by itself, 
you can create one of your own, pass it along and see the validator fill it 
with valuable information.

```php
<?php
$validator = new \HylianShield\Validator\CoreFunction();
$context = $validator::createContext();
$validator->validate('My epic function', $context);

echo $context;
```

Which will output:

```
Context:
#1 Assertion - Validator is callable: Yes
#2 Intention - Passing context to registered validator.
#3 Violation - Function "My epic function" does not exist - Violation code #2
#4 Assertion - Validation was successful: No
```

You can get the intentions, assertions and violations individually from the 
context, using their respective getters:

```php
<?php
$context->getAssertions(); // Assertion[]
$context->getIntentions(); // Intention[]
$context->getViolations(); // Violation[]
```

To get a complete picture of a context, here is a dump of the previously used
 context:
 
```
class HylianShield\Validator\Context\Context#809 (1) {
  protected $indications =>
  array(4) {
    [0] =>
    class HylianShield\Validator\Context\Indication\Assertion#810 (2) {
      protected $result =>
      bool(true)
      protected $description =>
      string(21) "Validator is callable"
    }
    [1] =>
    class HylianShield\Validator\Context\Indication\Intention#811 (1) {
      protected $description =>
      string(40) "Passing context to registered validator."
    }
    [2] =>
    class HylianShield\Validator\Context\Indication\Violation#812 (3) {
      protected $code =>
      int(2)
      protected $context =>
      array(1) {
        ...
      }
      protected $description =>
      string(31) "Function ":name" does not exist"
    }
    [3] =>
    class HylianShield\Validator\Context\Indication\Assertion#813 (2) {
      protected $result =>
      bool(false)
      protected $description =>
      string(25) "Validation was successful"
    }
  }
}
```

### Intentions

Intentions are exactly what they are called. They are what the validator 
intends to do. If at some point your code breaks because of the intention of 
a validator, you should be able to make use of this information.

#### Adding an intention

```php
<?php
$context->addIntention('Skip validation rule #3');
```

### Assertions

Assertions are simply findings the validator made while walking through 
validation rules. If at some point your validator appears to apply the wrong 
rules to your input, it can be useful to see if the validator made a wrong 
assumption.

#### Adding an assertion

```php
<?php
$options = array();

$context->addAssertion(
    'Array of options is empty',
    empty($options)
);
```

### Violations

The violations tell us the reasons why a validator decided to call your 
supplied data invalid.

#### Adding a violation

```php
<?php
$context->addViolation(
    'The function ":name" does not exist',
    CoreFunction::VIOLATION_EXISTS,
    array(
        'name' => 'My awesome function'
    )
);

echo $context;
```

Which will output:

```
Context:
#1 Violation - The function "My awesome function" does not exist - Violation code #2
```

#### Translating a violation

Since we do not want to show our users the same violation per se, 
but perhaps make use of its context, or we do not serve English users, 
we can translate the violation.

```php
<?php
use \HylianShield\Validator\Context\Indication\Violation;

$violation = new Violation(
    'The function ":name" does not exist',
    CoreFunction::VIOLATION_EXISTS,
    array(
        'name' => 'My awesome function'
    )
);

echo $violation->interpolate('We have a loopy function called :name');
// 'We have a loopy function called My awesome function'

echo $violation->interpolate('Failing function: {name}', '{', '}');
// Failing function: My awesome function
```
